用 MFC 类库编程实现工作者线程

例程5 MultiThread5

为了与Win32 API对照，我们使用MFC 类库编程实现例程3 MultiThread3。

建立一个基于对话框的工程MultiThread5，在对话框IDD_MULTITHREAD5_DIALOG中加入一个编辑框IDC_MILLISECOND，一个按钮IDC_START，标题为“开始” ，一个进度条IDC_PROGRESS1； 
打开ClassWizard，为编辑框IDC_MILLISECOND添加int型变量m_nMilliSecond，为进度条IDC_PROGRESS1添加CProgressCtrl型变量m_ctrlProgress； 
在MultiThread5Dlg.h文件中添加一个结构的定义： struct threadInfo
{
	UINT nMilliSecond;
	CProgressCtrl* pctrlProgress;
};

线程函数的声明：UINT ThreadFunc(LPVOID lpParam); 
注意，二者应在类CMultiThread5Dlg的外部。

在类CMultiThread5Dlg内部添加protected型变量：

CWinThread* pThread; 
在MultiThread5Dlg.cpp文件中进行如下操作：定义公共变量：threadInfo Info; 
双击按钮IDC_START，添加相应消息处理函数：

void CMultiThread5Dlg::OnStart() 
{
	// TODO: Add your control notification handler code here

	UpdateData(TRUE);
	Info.nMilliSecond=m_nMilliSecond;
	Info.pctrlProgress=&m_ctrlProgress;

	pThread=AfxBeginThread(ThreadFunc,
		&Info);
}

在函数BOOL CMultiThread3Dlg::OnInitDialog()中添加语句： {
	……
	
	// TODO: Add extra initialization here
	m_ctrlProgress.SetRange(0,99);
	m_nMilliSecond=10;
	UpdateData(FALSE);
	return TRUE;  // return TRUE  unless you set the focus to a control
}

添加线程处理函数： UINT ThreadFunc(LPVOID lpParam)
{
	threadInfo* pInfo=(threadInfo*)lpParam;
	for(int i=0;i<100;i++)
	{
		int nTemp=pInfo->nMilliSecond;

		pInfo->pctrlProgress->SetPos(i);

		Sleep(nTemp);
	}
	return 0;
}

程序中另外一个线程完全仿照此线程